/**
 * Strategy Constraints - Prevent generation of invalid strategies
 *
 * These constraints ensure that strategies generated by the GA are within
 * realistic operational bounds BEFORE simulation runs.
 */

import type { Strategy } from '../simulation/types.js';

/**
 * Strategy Parameter Bounds - Hard limits on what the GA can generate
 */
export const STRATEGY_BOUNDS = {
  // MCE Allocation: Balance custom capacity with standard revenue generation
  // With 25-32 custom orders/day and MCE capacity of 30 units/day/machine:
  // 60% = 18 units/day custom (allows backlog but manageable)
  // 40% = 12 units/day standard (consistent revenue to pay salaries)
  mceAllocationCustom: { min: 0.30, max: 0.60 }, // Give custom 30-60% of MCE capacity (balanced)

  // Standard Pricing: Must be profitable but not price ourselves out of market
  standardPrice: { min: 400, max: 1200 }, // Below $400 likely unprofitable, above $1200 no demand

  // Overtime: Limited by business case
  dailyOvertimeHours: { min: 0, max: 4 }, // 0-4 hours per day allowed

  // Custom Pricing: Keep near data-driven values
  customBasePrice: { min: 90, max: 120 }, // Near regression baseline of $106.56
  customPenaltyPerDay: { min: 0.20, max: 0.35 }, // Near regression slope of $0.27
  customTargetDeliveryDays: { min: 5, max: 7 }, // Target 5-7 days delivery

  // Demand Model: Keep near historical data
  customDemandMean1: { min: 20, max: 30 }, // Phase 1 mean
  customDemandStdDev1: { min: 3, max: 8 }, // Phase 1 std dev
  customDemandMean2: { min: 28, max: 38 }, // Phase 2 mean (30% increase)
  customDemandStdDev2: { min: 4, max: 10 }, // Phase 2 std dev

  // Standard Demand: Keep near user input
  standardDemandIntercept: { min: 400, max: 600 }, // Near 500
  standardDemandSlope: { min: -0.35, max: -0.15 }, // Near -0.25

  // Quit Risk Model: Keep near business case
  overtimeTriggerDays: { min: 3, max: 7 }, // 3-7 consecutive days
  dailyQuitProbability: { min: 0.05, max: 0.20 }, // 5-20% quit chance
} as const;

/**
 * Apply bounds to a strategy parameter
 */
export function applyBound<T extends keyof typeof STRATEGY_BOUNDS>(
  param: T,
  value: number
): number {
  const bounds = STRATEGY_BOUNDS[param];
  return Math.max(bounds.min, Math.min(bounds.max, value));
}

/**
 * Constrain a strategy to valid bounds
 */
export function constrainStrategy(strategy: Strategy): Strategy {
  return {
    ...strategy,
    mceAllocationCustom: applyBound('mceAllocationCustom', strategy.mceAllocationCustom),
    standardPrice: applyBound('standardPrice', strategy.standardPrice),
    dailyOvertimeHours: applyBound('dailyOvertimeHours', strategy.dailyOvertimeHours),
    customBasePrice: applyBound('customBasePrice', strategy.customBasePrice),
    customPenaltyPerDay: applyBound('customPenaltyPerDay', strategy.customPenaltyPerDay),
    customTargetDeliveryDays: applyBound('customTargetDeliveryDays', strategy.customTargetDeliveryDays),
    customDemandMean1: applyBound('customDemandMean1', strategy.customDemandMean1),
    customDemandStdDev1: applyBound('customDemandStdDev1', strategy.customDemandStdDev1),
    customDemandMean2: applyBound('customDemandMean2', strategy.customDemandMean2),
    customDemandStdDev2: applyBound('customDemandStdDev2', strategy.customDemandStdDev2),
    standardDemandIntercept: applyBound('standardDemandIntercept', strategy.standardDemandIntercept),
    standardDemandSlope: applyBound('standardDemandSlope', strategy.standardDemandSlope),
    overtimeTriggerDays: applyBound('overtimeTriggerDays', strategy.overtimeTriggerDays),
    dailyQuitProbability: applyBound('dailyQuitProbability', strategy.dailyQuitProbability),
  };
}

/**
 * Validate strategy parameters before simulation
 * Returns true if strategy is within acceptable bounds
 */
export function isValidStrategy(strategy: Strategy): boolean {
  // Check all numeric parameters are within bounds
  for (const [param, bounds] of Object.entries(STRATEGY_BOUNDS)) {
    const value = strategy[param as keyof Strategy] as number;
    if (value < bounds.min || value > bounds.max) {
      console.warn(`Strategy parameter ${param} = ${value} outside bounds [${bounds.min}, ${bounds.max}]`);
      return false;
    }
  }

  // Additional business logic constraints
  // Custom demand phase 2 should be higher than phase 1 (market growth)
  if (strategy.customDemandMean2 < strategy.customDemandMean1) {
    console.warn('Custom demand phase 2 should be >= phase 1 (market growth)');
    return false;
  }

  // Standard demand slope must be negative (downward sloping demand curve)
  if (strategy.standardDemandSlope >= 0) {
    console.warn('Standard demand slope must be negative (price sensitivity)');
    return false;
  }

  // MCE allocation to custom should leave enough for standard line
  // Standard needs at least 15% to maintain minimum production
  if (strategy.mceAllocationCustom > 0.85) {
    console.warn('MCE allocation to custom too high, standard line would starve');
    return false;
  }

  return true;
}

/**
 * Generate a random strategy within valid bounds
 */
export function generateBoundedRandomStrategy(): Strategy {
  const strategy: Strategy = {
    // FORMULA-DRIVEN POLICIES: Set to 0, will be calculated dynamically
    reorderPoint: 0,
    orderQuantity: 0,
    standardBatchSize: 0,

    // GA-OPTIMIZABLE POLICIES: Random within bounds
    mceAllocationCustom:
      STRATEGY_BOUNDS.mceAllocationCustom.min +
      Math.random() * (STRATEGY_BOUNDS.mceAllocationCustom.max - STRATEGY_BOUNDS.mceAllocationCustom.min),

    standardPrice:
      STRATEGY_BOUNDS.standardPrice.min +
      Math.floor(Math.random() * (STRATEGY_BOUNDS.standardPrice.max - STRATEGY_BOUNDS.standardPrice.min)),

    dailyOvertimeHours: Math.floor(
      Math.random() * (STRATEGY_BOUNDS.dailyOvertimeHours.max + 1)
    ),

    // FIXED MARKET CONDITIONS: Use middle of allowed range
    customBasePrice: 106.56, // Data-driven baseline
    customPenaltyPerDay: 0.27, // Data-driven slope
    customTargetDeliveryDays: 5, // Target 5 days (within 7-day hard limit)

    // FIXED DEMAND MODEL: Use middle of allowed range
    customDemandMean1: 25,
    customDemandStdDev1: 5,
    customDemandMean2: 32.5, // 30% increase from phase 1
    customDemandStdDev2: 6.5,

    // FIXED STANDARD DEMAND CURVE
    standardDemandIntercept: 500,
    standardDemandSlope: -0.25,

    // FIXED QUIT RISK MODEL
    overtimeTriggerDays: 5,
    dailyQuitProbability: 0.10,

    // Timed actions (evolved by GA)
    timedActions: [],
  };

  return strategy;
}

/**
 * Generate a cash-flow-aware strategy with guaranteed cash flow safety
 * This ensures strategies start with solid fundamentals and are less likely to fail validation
 */
export function generateCashFlowAwareStrategy(): Strategy {
  // Start with bounded random strategy
  const strategy = generateBoundedRandomStrategy();

  // GUARANTEED CASH FLOW SAFETY: Always include early loans
  // These loans ensure the factory has operating capital throughout the simulation
  // EOQ based on MCE capacity (45 parts/day): ~1,812 parts = $91,600 per order
  // Starting cash: $8,206 - need ~$84K to afford first material order + working capital buffer
  const guaranteedLoans = [
    { day: 51, type: 'TAKE_LOAN' as const, amount: 100000 + Math.floor(Math.random() * 20000) }, // $100K-$120K (covers first material order)
    { day: 70, type: 'TAKE_LOAN' as const, amount: 80000 + Math.floor(Math.random() * 20000) }, // $80K-$100K (covers subsequent orders)
    { day: 100, type: 'TAKE_LOAN' as const, amount: 60000 + Math.floor(Math.random() * 20000) }, // $60K-$80K (supplemental capital)
  ];

  // GUARANTEED INVENTORY SAFETY: Always include early material order
  // This ensures the factory doesn't hit stockouts in the critical early period
  const guaranteedMaterialOrder = [
    { day: 51, type: 'ORDER_MATERIALS' as const, quantity: 300 + Math.floor(Math.random() * 200) }, // 300-500 units
  ];

  // GUARANTEED WORKFORCE GROWTH: Always include hiring actions
  // Without hiring, the factory cannot scale to meet demand
  const guaranteedHiring = [
    { day: 60 + Math.floor(Math.random() * 20), type: 'HIRE_ROOKIE' as const, count: 1 + Math.floor(Math.random() * 2) }, // Hire 1-2 rookies around day 60-80
    { day: 120 + Math.floor(Math.random() * 30), type: 'HIRE_ROOKIE' as const, count: 1 + Math.floor(Math.random() * 2) }, // Hire 1-2 rookies around day 120-150
  ];

  // ADDITIONAL RANDOM ACTIONS: Add 3-8 more actions for GA to optimize
  const additionalActions = [];
  const numAdditionalActions = 3 + Math.floor(Math.random() * 6); // 3-8 actions

  for (let i = 0; i < numAdditionalActions; i++) {
    const day = 51 + Math.floor(Math.random() * 400); // Days 51-450
    const actionType = Math.random();

    if (actionType < 0.3) {
      // Additional loan
      additionalActions.push({
        day,
        type: 'TAKE_LOAN' as const,
        amount: 20000 + Math.floor(Math.random() * 80000), // $20K-$100K
      });
    } else if (actionType < 0.5) {
      // Additional hiring
      additionalActions.push({
        day,
        type: 'HIRE_ROOKIE' as const,
        count: 1 + Math.floor(Math.random() * 2), // 1-2 rookies
      });
    } else if (actionType < 0.7) {
      // Additional material order
      additionalActions.push({
        day,
        type: 'ORDER_MATERIALS' as const,
        quantity: 200 + Math.floor(Math.random() * 500), // 200-700 units
      });
    } else {
      // Machine purchase
      const machineTypes: Array<'MCE' | 'WMA' | 'PUC'> = ['MCE', 'WMA', 'PUC'];
      additionalActions.push({
        day,
        type: 'BUY_MACHINE' as const,
        machineType: machineTypes[Math.floor(Math.random() * machineTypes.length)],
        count: 1,
      });
    }
  }

  // Combine all actions and sort by day
  strategy.timedActions = [
    ...guaranteedLoans,
    ...guaranteedMaterialOrder,
    ...guaranteedHiring,
    ...additionalActions,
  ].sort((a, b) => a.day - b.day);

  return strategy;
}
